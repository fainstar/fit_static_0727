# 物件偵測網站系統架構

本文件深入探討一個完全在瀏覽器端運行的物件偵測網站的系統架構、設計決策與效能考量。

## 核心架構：純前端推論 (Serverless Inference)

此專案採用**純前端 (Client-Side Only)** 架構，其核心理念是將所有運算，特別是計算密集型的模型推論，完全放在使用者的瀏覽器中執行。這造就了一個無後端應用程式邏輯、僅依賴靜態檔案伺服器的「無伺服器推論」模型。

### 架構圖

```
╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                    用戶端 (Browser)                                                    ║
╠════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╣
║                                                                                                                    ║
║   ┌───────────┐   上傳圖片   ┌───────────┐   觸發事件   ┌──────────────────┐                                           ║
║   │  使用者   ├────────────>│    UI     ├────────────>│   應用程式邏輯   │                                           ║
║   └─────┬─────┘              └─────┬─────┘              └────────┬─────────┘                                           ║
║         │                          │                            │                                                   ║
║         │ 顯示偵測結果             │                            │ 調用                                              ║
║         └──────────────────────────┘                            │                                                   ║
║                                                                   │                                                   ║
║                                                                   ▼                                                   ║
║                                                            ┌──────────────┐                                            ║
║                                                            │ 推論處理器   │                                            ║
║                                                            └──────┬───────┘                                            ║
║                                                                   │ 1. 預處理                                         ║
║                                                                   │ 2. 執行推論 (ONNX Runtime Web)                    ║
║                                                                   │ 3. 後處理 (NMS)                                   ║
║                                                                   │                                                   ║
║                                                                   ▼                                                   ║
║                                                            ┌──────────────┐                                            ║
║   ┌────────────┐ <────── 使用 ───────────┤      結果      ├───────────> 返回最終結果 ───────────────────────────┐ ║
║   │  模型檔案  │                                            └──────────────┘                                            │ ║
║   └────────────┘                                                                                                       │ ║
║         ^                                                                                                              │ ║
║         └──────────────────────────────────────────────────────────────────────────────────────────────────────────────┘ ║
║                                                                                                                    ║
╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝

╔════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╗
║                                                  伺服器端 (Deployment)                                                 ║
╠════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╣
║                                                                                                                    ║
║   ┌───────────────┐      運行      ┌──────────────────┐   提供靜態資源   ┌───────────┐                                ║
║   │ Docker 容器   ├────────────>│ Nginx Web Server ├──────────────>│    UI     │                                ║
║   └───────────────┘                └──────────────────┘                  └───────────┘                                ║
║                                                                                                                    ║
╚════════════════════════════════════════════════════════════════════════════════════════════════════════════════════════╝
```

## 架構決策與權衡

選擇純前端架構是基於以下幾點考量：

1.  **降低伺服器成本與複雜度**
    -   **優點**: 無需維護複雜的後端應用程式、GPU 伺服器或雲端推論服務 (如 AWS SageMaker)，大幅降低營運成本與維護負擔。
    -   **權衡**: 所有運算壓力轉移至使用者裝置，可能影響低階裝置的效能與使用者體驗。

2.  **保障使用者資料隱私**
    -   **優點**: 圖片資料完全在本地處理，不需上傳至任何伺服器，最大程度地保護了使用者的隱私。
    -   **權衡**: 無法在伺服器端收集或分析資料，限制了某些商業模式的可能性。

3.  **高可擴展性與離線能力**
    -   **優點**: 由於伺服器僅提供靜態檔案，可輕易透過 CDN 在全球範圍內分發，實現極高的可擴展性。一旦資源載入完成，應用程式甚至可以在離線狀態下運行。
    -   **權衡**: 模型檔案可能較大，初次載入時間可能較長，需要良好的快取策略來優化。

### 為何使用 ONNX Runtime Web？

ONNX Runtime Web 是此架構的基石，它讓我們能在瀏覽器中高效執行 ONNX 模型。

-   **跨平台與高效能**: 藉助 WebAssembly (WASM) 和 WebGL，它能在 CPU 和 GPU 上實現接近原生的運算速度。
-   **模型互通性**: ONNX 作為一個開放標準，讓我們可以輕易地從主流訓練框架 (PyTorch, TensorFlow) 轉換模型。

## 效能考量與優化

在純前端架構中，效能至關重要。

1.  **非阻塞 UI**: 
    -   **問題**: 模型推論是同步且計算密集的任務，直接在主執行緒中運行會導致 UI 凍結。
    -   **解決方案**: 將 ONNX Runtime 的推論過程放在 **Web Worker** 中執行。這能將繁重運算移至背景執行緒，確保主執行緒保持流暢，從而提升使用者體驗。

2.  **模型載入與快取**: 
    -   **問題**: ONNX 模型檔案通常很大 (數十至數百 MB)，每次訪問都重新下載會嚴重影響載入速度。
    -   **解決方案**: 
        -   **Nginx 快取**: 在 `nginx.conf` 中為 `.onnx` 檔案設定積極的瀏覽器快取策略 (e.g., `expires 1y;`)，讓瀏覽器在初次下載後快取模型。
        -   **IndexedDB**: 對於更精細的控制，可以使用 IndexedDB 將模型檔案儲存在瀏覽器中，實現更可靠的離線存取。

3.  **模型優化**: 
    -   **問題**: 原始模型可能過於龐大或複雜，不適合在資源受限的瀏覽器環境中運行。
    -   **解決方案**: 在部署前對模型進行**量化 (Quantization)** 或**剪枝 (Pruning)**。例如，將 FP32 模型量化為 INT8，可以在犧牲極少精度的情況下，大幅縮小模型體積並提升推論速度。

## 部署與啟動

本專案使用 Docker 和 Nginx 進行標準化部署。

1.  **建立映像檔**: `docker build -t object-detection-web .`
2.  **運行容器**: `docker run -d -p 8080:80 --name my-app object-detection-web`
3.  **訪問**: `http://localhost:8080`